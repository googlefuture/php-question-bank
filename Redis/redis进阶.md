# redis进阶知识汇总

## 缓存穿透、缓存雪崩、缓存击穿

缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数 据库中查询。 

缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中 

缓存雪崩：就是大量数据同一时间失效。

> 打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有netflix的会员， 然后你把这些账号和密码发布到一个你自己做的网站上，然后你有一个朋友每过十秒钟就查询你的网站，发现你 的网站没有Netflix的会员后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是缓存穿透。 大家都喜欢看腾讯视频上的《水果传》，但是你的会员突然到期了，大家在你的网站上看不到腾讯视频的账号， 纷纷打电话向你询问，这就是缓存击穿 你的各种会员突然同一时间都失效了，那这就是缓存雪崩了。


### 缓存穿透： 
1. 接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id<=0的直接拦截； 

2. 缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户 反复用同一个id暴力攻击 

### 缓存击穿： 
最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员 

### 缓存雪崩： 
1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 

2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。


## Redis为什么快？
1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap， HashMap的优势就是查找和操作的时间复杂度都是O(1)； 
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的； 
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU， 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 
4. 使用多路I/O复用模型，非阻塞IO； 
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； 

以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨： 

（1）多路 I/O 复用模型 

多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前 线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是 只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高 效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说 内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。