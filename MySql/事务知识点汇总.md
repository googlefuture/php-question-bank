# 事务知识汇总

## 什么是事务？
事务就是为了保证一组数据库操作，要么全部成功，要么全部失败。

事务是在引擎层实现的，也就是说并不是所有引擎都可以使用事务，MyISAM 就不支持事务，这也是为什么会被 InnoDB 取代的原因。

## 事务的四大特性？
原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

- 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

- 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

- 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

- 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 没有隔离级别的话，多事务并发进行会造成什么问题？

- 脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.
- 不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.
- 幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".

## 事务的隔离级别和各自解决的问题是什么？
隔离性可能会引入**脏读（dirty read）**、**不可重复读（non-repeatable read）**、**幻读（phantom read）** 等问题，为了解决这些问题就引入了“隔离级别”的概念。

**SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable）：**

- **读未提交**：一个事务还没提交时，它做的变更就能被别的事务看到。
- **读提交**：一个事务提交之后，它做的变更才会被其他事务看到。
- **可重复读**： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- **串行化**： 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

SQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

|隔离级别|脏读|不可重复读|幻读|
|-----|-----|-----|---- |
|读未提交 |	可能|	可能|	可能|
|读提交 |	不可能|	可能|	可能|
|可重复读 |	不可能|	不可能|	可能|
|串行化 |	不可能|	不可能|	不可能|


## InnoDB使用的是哪种隔离级别呢?
InnoDB默认使用的是**可重复读隔离**级别. RR


